{"version":3,"file":"snabbdom.min.js","mappings":"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","sources":["webpack://snabbdom/webpack/universalModuleDefinition","webpack://snabbdom/webpack/bootstrap","webpack://snabbdom/webpack/runtime/define property getters","webpack://snabbdom/webpack/runtime/hasOwnProperty shorthand","webpack://snabbdom/webpack/runtime/make namespace object","webpack://snabbdom/./src/htmldomapi.ts","webpack://snabbdom/./src/vnode.ts","webpack://snabbdom/./src/is.ts","webpack://snabbdom/./src/init.ts","webpack://snabbdom/./src/h.ts","webpack://snabbdom/./src/thunk.ts","webpack://snabbdom/./src/modules/attributes.ts","webpack://snabbdom/./src/modules/class.ts","webpack://snabbdom/./src/modules/dataset.ts","webpack://snabbdom/./src/modules/eventlisteners.ts","webpack://snabbdom/./src/modules/props.ts","webpack://snabbdom/./src/modules/style.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"snabbdom\"] = factory();\n\telse\n\t\troot[\"snabbdom\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\r\n * 对 DOM API 进行进一步封装\r\n */\r\nexport interface DOMAPI {\r\n  createElement: (\r\n    tagName: any,\r\n    options?: ElementCreationOptions\r\n  ) => HTMLElement\r\n  createElementNS: (\r\n    namespaceURI: string,\r\n    qualifiedName: string,\r\n    options?: ElementCreationOptions\r\n  ) => Element\r\n  createDocumentFragment?: () => DocumentFragment\r\n  createTextNode: (text: string) => Text\r\n  createComment: (text: string) => Comment\r\n  insertBefore: (\r\n    parentNode: Node,\r\n    newNode: Node,\r\n    referenceNode: Node | null\r\n  ) => void\r\n  removeChild: (node: Node, child: Node) => void\r\n  appendChild: (node: Node, child: Node) => void\r\n  parentNode: (node: Node) => Node | null\r\n  nextSibling: (node: Node) => Node | null\r\n  tagName: (elm: Element) => string\r\n  setTextContent: (node: Node, text: string | null) => void\r\n  getTextContent: (node: Node) => string | null\r\n  isElement: (node: Node) => node is Element\r\n  isText: (node: Node) => node is Text\r\n  isComment: (node: Node) => node is Comment\r\n  isDocumentFragment?: (node: Node) => node is DocumentFragment\r\n}\r\n\r\nfunction createElement(\r\n  tagName: any,\r\n  options?: ElementCreationOptions\r\n): HTMLElement {\r\n  return document.createElement(tagName, options)\r\n}\r\n\r\nfunction createElementNS(\r\n  namespaceURI: string,\r\n  qualifiedName: string,\r\n  options?: ElementCreationOptions\r\n): Element {\r\n  return document.createElementNS(namespaceURI, qualifiedName, options)\r\n}\r\n\r\nfunction createDocumentFragment(): DocumentFragment {\r\n  return document.createDocumentFragment()\r\n}\r\n\r\nfunction createTextNode(text: string): Text {\r\n  return document.createTextNode(text)\r\n}\r\n\r\nfunction createComment(text: string): Comment {\r\n  return document.createComment(text)\r\n}\r\n/**\r\n * \r\n * @param parentNode 父节点\r\n * @param newNode 要插入的节点\r\n * @param referenceNode 标杆节点，即在该节点前插入新节点，如果未指定则将新节点插入到父节点末尾\r\n */\r\nfunction insertBefore(\r\n  parentNode: Node,\r\n  newNode: Node,\r\n  referenceNode: Node | null\r\n): void {\r\n  parentNode.insertBefore(newNode, referenceNode)\r\n}\r\n\r\nfunction removeChild(node: Node, child: Node): void {\r\n  node.removeChild(child)\r\n}\r\n\r\nfunction appendChild(node: Node, child: Node): void {\r\n  node.appendChild(child)\r\n}\r\n\r\nfunction parentNode(node: Node): Node | null {\r\n  return node.parentNode\r\n}\r\n\r\nfunction nextSibling(node: Node): Node | null {\r\n  return node.nextSibling\r\n}\r\n\r\nfunction tagName(elm: Element): string {\r\n  return elm.tagName\r\n}\r\n\r\nfunction setTextContent(node: Node, text: string | null): void {\r\n  node.textContent = text\r\n}\r\n\r\nfunction getTextContent(node: Node): string | null {\r\n  return node.textContent\r\n}\r\n\r\nfunction isElement(node: Node): node is Element {\r\n  return node.nodeType === 1\r\n}\r\n\r\nfunction isText(node: Node): node is Text {\r\n  return node.nodeType === 3\r\n}\r\n\r\nfunction isComment(node: Node): node is Comment {\r\n  return node.nodeType === 8\r\n}\r\n\r\nfunction isDocumentFragment(node: Node): node is DocumentFragment {\r\n  return node.nodeType === 11\r\n}\r\n\r\nexport const htmlDomApi: DOMAPI = {\r\n  createElement,\r\n  createElementNS,\r\n  createTextNode,\r\n  createDocumentFragment,\r\n  createComment,\r\n  insertBefore,\r\n  removeChild,\r\n  appendChild,\r\n  parentNode,\r\n  nextSibling,\r\n  tagName,\r\n  setTextContent,\r\n  getTextContent,\r\n  isElement,\r\n  isText,\r\n  isComment,\r\n  isDocumentFragment,\r\n}\r\n\r\n// END\r\n","import { Hooks } from './hooks'\r\nimport { VNodeStyle } from './modules/style'\r\nimport { On } from './modules/eventListeners'\r\nimport { Attrs } from './modules/attributes'\r\nimport { Classes } from './modules/class'\r\nimport { Props } from './modules/props'\r\nimport { Dataset } from './modules/dataset'\r\n\r\nexport type Key = string | number | symbol\r\n\r\nexport interface VNode {\r\n  sel: string | undefined\r\n  data: VNodeData | undefined\r\n  children: Array<VNode | string> | undefined\r\n  text: string | undefined\r\n  elm: Node | undefined\r\n  key: Key | undefined\r\n}\r\n\r\nexport interface VNodeData {\r\n  props?: Props // props 模块插件\r\n  attrs?: Attrs // attributes 模块插件\r\n  class?: Classes // class 模块插件\r\n  style?: VNodeStyle // style 模块插件\r\n  dataset?: Dataset // dataset 模块插件\r\n  on?: On // eventListeners 模块插件\r\n  hook?: Hooks // 生命周期钩子\r\n  key?: Key // 元素唯一标识\r\n  ns?: string // 针对 svg 标签的命名空间\r\n  fn?: () => VNode // thunk 的生成函数\r\n  args?: any[] // thunk 的生成函数的参数\r\n  is?: string // TODO: 暂时不知道他的用法\r\n  [key: string]: any // 第三方模块扩展\r\n}\r\n\r\n/**\r\n * vnode函数的作用是根据传入的信息返回封装好的 VNode 对象\r\n * \r\n * @param sel sel为 selector 的意思，意为 DOM 选择器\r\n * @param data 属性，对 VNode 的扩展\r\n * @param children vnode 的子节点，可以为 vnode 数组或 string 数组或 undefined，分别表示 dom 节点、文本节点、无节点\r\n * @param text 文本节点\r\n * @param elm // 真实的节点\r\n * @returns VNode\r\n */\r\nexport function vnode(\r\n  sel: string | undefined,\r\n  data: VNodeData | undefined,\r\n  children: Array<VNode | string> | undefined,\r\n  text: string | undefined,\r\n  elm: Element | DocumentFragment | Text | undefined\r\n): VNode {\r\n  const key = data === undefined ? undefined : data.key // VNode 的唯一标识\r\n\r\n  return {\r\n    sel, data, children, text, elm, key\r\n  }\r\n}\r\n","/**\r\n * 这个文件暴露类型判断的方法\r\n */\r\n\r\n/**\r\n * Array.isArray\r\n */\r\nexport const array = Array.isArray\r\n/**\r\n * 判断 s 是否为数字或布尔值，或他的原始类型是否为数字或布尔值\r\n * @param s \r\n * @returns 布尔值\r\n */\r\nexport function primitive(s: any): s is string | number {\r\n  return (\r\n    typeof s === \"string\" ||\r\n    typeof s === \"number\" ||\r\n    s instanceof String ||\r\n    s instanceof Number\r\n  )\r\n}\r\n\r\n// END\r\n","import { Module } from './modules/module'\nimport { vnode, VNode } from './vnode'\nimport * as is from './is'\nimport { htmlDomApi, DOMAPI } from './htmldomapi'\n\ntype NonUndefined<T> = T extends undefined ? never : T // 非 undefined 类型\n\n/**\n * 判断一个值是否为 undefined\n * @param s \n * @returns 布尔值\n */\nfunction isUndef(s: any): boolean {\n  return s === undefined\n}\n\n/**\n * 判断一个值是否已定义\n * @param s \n * @returns 布尔值\n */\nfunction isDef<A>(s: A): s is NonUndefined<A> {\n  return s !== undefined\n}\n\ntype VNodeQueue = VNode[]\n\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined)\n\n/**\n * 判断两个 VNode 的 key、is、sel 是否都相同\n * @param vnode1 \n * @param vnode2 \n * @returns 布尔值\n */\nfunction sameVnode(vnode1: VNode, vnode2: VNode): boolean {\n  const isSameKey = vnode1.key === vnode2.key\n  const isSameIs = vnode1.data?.is === vnode2.data?.is\n  const isSameSel = vnode1.sel === vnode2.sel\n\n  return isSameSel && isSameKey && isSameIs\n}\n\nfunction documentFragmentIsNotSupported(): never {\n  throw new Error(\"The document fragment is not supported on this platform.\")\n}\n\nfunction isElement(\n  api: DOMAPI,\n  vnode: Element | DocumentFragment | VNode\n): vnode is Element {\n  return api.isElement(vnode as any)\n}\n\nfunction isDocumentFragment(\n  api: DOMAPI,\n  vnode: DocumentFragment | VNode\n): vnode is DocumentFragment {\n  return api.isDocumentFragment!(vnode as any)\n}\n\ntype KeyToIndexMap = { [key: string]: number }\n\ntype ArraysOf<T> = {\n  [K in keyof T]: Array<T[K]>\n}\n\ntype ModuleHooks = ArraysOf<Required<Module>> // Required 泛型：泛型中的所有属性都必须是必选项\n\n/**\n * 创建一个缓存表，用于存储 oldVNodes 中带有 key 值的 VNode 的索引位置\n * @param children VNode 数组\n * @param beginIdx 起始指针\n * @param endIdx 结束指针\n * @returns 缓存表\n */\nfunction createKeyToOldIdx(\n  children: VNode[],\n  beginIdx: number,\n  endIdx: number\n): KeyToIndexMap {\n  const map: KeyToIndexMap = {}\n  for (let i = beginIdx; i <= endIdx; ++i) {\n    const key = children[i]?.key\n    if (key !== undefined) {\n      map[key as string] = i\n    }\n  }\n  return map\n}\n\nconst hooks: Array<keyof Module> = [\n  \"create\",\n  \"update\",\n  \"remove\",\n  \"destroy\",\n  \"pre\",\n  \"post\",\n]\n\nexport type Options = { // 处理一些实验性 api 的配置\n  experimental?: {\n    fragments?: boolean // 是否开启 fragment\n  }\n}\n\n/**\n * init 调用了 init hook、create hook，并将带有 insert hook 的 VNode 推入等待队列。\n * \n * @param modules 每一个 module 都是一个包含 hooks 的对象\n * @param domApi 封装好的 DOM 处理器\n * @param options 实验性 API 的配置\n * @returns patch\n */\nexport function init(\n  modules: Array<Partial<Module>>,\n  domApi?: DOMAPI,\n  options?: Options\n) {\n  const cbs: ModuleHooks = { // 整理 hooks 列表\n    create: [],\n    update: [],\n    remove: [],\n    destroy: [],\n    pre: [],\n    post: [],\n  }\n\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi\n\n  for (const hook of hooks) { // 遍历 hooks 名单，在 module 中筛选出符合条件的 hook 写进 cbs\n    for (const module of modules) {\n      const currentHook = module[hook]\n      if (currentHook !== undefined) {\n        (cbs[hook] as any[]).push(currentHook)\n      }\n    }\n  }\n\n  /**\n   * 根据真实 DOM 创建一个空的 VNode，在真实 DOM 与 VNode 进行 patch 就需要把真实 DOM 转为空的 VNode\n   * @param elm 真实 DOM\n   * @returns VNode\n   */\n  function emptyNodeAt(elm: Element): VNode {\n    const id = elm.id ? \"#\" + elm.id : \"\" // id 选择器，如 #aaa\n\n    const classes = elm.getAttribute(\"class\")\n\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\" // 类选择器，如 .b.c\n    return vnode(\n      api.tagName(elm).toLowerCase() + id + c, // div#a\n      {},\n      [],\n      undefined,\n      elm\n    )\n  }\n\n  /**\n   * 根据 DocumentFragment 创建空的 VNode\n   * @param frag DocumentFragment\n   * @returns VNode \n   */\n  function emptyDocumentFragmentAt(frag: DocumentFragment): VNode {\n    return vnode(undefined, {}, [], undefined, frag)\n  }\n\n  /**\n   * 返回一个回调函数，每次调用 listeners - 1，当 listeners = 0 时，childElm 节点会被删除\n   * @param childElm 儿子节点\n   * @param listeners 计数器\n   * @returns rmCb\n   */\n  function createRmCb(childElm: Node, listeners: number) {\n    return function rmCb() {\n      if (--listeners === 0) { // 如果计数器到零，则删除儿子节点\n        const parent = api.parentNode(childElm) as Node\n        api.removeChild(parent, childElm)\n      }\n    }\n  }\n\n  /**\n   * 根据 VNode 创建真实 DOM，并绑定在 VNode.elm 上，返回 Node。\n   * \n   * createElm 会根据以下情况创建节点：\n   *  1、当 sel 为 ! 时，此时 VNode 为注释节点，创建注释节点。\n   *  2、当 sel 不为 undefined 时，此时 VNode 为 DOM 节点，创建 DOM 节点：\n   *    i、当 children 为数组时，递归创建 Elm 并添加到父节点中。\n   *    ii、当 children 不为数组时，根据 text 创建文本节点并添加到父节点中。\n   *  3、当 sel 为 undefined 且 fragments 选项开启、且 children 为数组时，创建 DocumentFragment，递归创建 Elm 并添加到 DocumentFragment 中。\n   *  4、当 sel、children 为 undefined 时，此时 VNode 为文本节点，创建文本节点。\n   * \n   * @param vnode VNode\n   * @param insertedVnodeQueue VNode 等待队列，里面的 VNode 在挂载完毕后将被处理\n   * @returns Node\n   */\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any\n    let data = vnode.data\n    if (data !== undefined) { // data 不为 undefined，说明有属性值，需要处理 data 属性\n      const init = data.hook?.init // VNode 的 init hook，VNode 被添加时执行\n      if (isDef(init)) {\n        init(vnode)\n        data = vnode.data\n      }\n    }\n    const children = vnode.children\n    const sel = vnode.sel\n    /********************\n     * 处理 sel 的情况\n     * ***************\n     */\n    if (sel === '!') { // se l为 !，说明是注释节点\n      if (isUndef(vnode.text)) {\n        vnode.text = ''\n      }\n      vnode.elm = api.createComment(vnode.text!) // 创建真实的注释节点\n    } else if (sel !== undefined) { // sel 不为 undefined，说明是一个 DOM 节点\n      // 处理选择器\n      const hashIdx = sel.indexOf('#')\n      const dotIdx = sel.indexOf('.', hashIdx)\n      const hash = hashIdx > 0 ? hashIdx : sel.length\n      const dot = dotIdx > 0 ? dotIdx : sel.length\n      const tag = // 标签\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel\n      const elm = (vnode.elm = // DOM 元素\n        isDef(data) && isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data))\n      if (hash < dot) { // 如果有 id，设置 id\n        elm.setAttribute('id', sel.slice(hash + 1, dot))\n      }\n      if (dotIdx > 0) { // 如果有 class，设置 class\n        elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' '))\n      }\n      /******************************\n       * 执行 modules 的 create hook\n       * **************************\n       */\n      for (i = 0; i < cbs.create.length; ++i) { // 基于 VNode 的 DOM 元素被创建，把收集的 create hooks 全部执行\n        cbs.create[i](emptyNode, vnode)\n      }\n      /*****************************\n       * 下面是处理 children 的情况\n       * *************************\n       */\n      if (is.array(children)) { // 如果 children 是数组，递归创建 Elm\n        for (i = 0; i < children.length; ++i) {\n          const ch = children[i]\n          if (ch !== null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue))\n          }\n        }\n      } else if (is.primitive(vnode.text)) { // 如果 children 不是一个数组，那么检查 text，如果有 text，那就创建文本节点\n        api.appendChild(elm, api.createTextNode(vnode.text))\n      }\n      const hook = vnode.data!.hook\n      if (isDef(hook)) {\n        hook.create?.(emptyNode, vnode) // VNode create hook 被调用\n        if (hook.insert) { // 如果有 insert hook，那么把 VNode 推入等待队列\n          insertedVnodeQueue.push(vnode)\n        }\n      }\n    } else if (options?.experimental?.fragments && vnode.children) { // 当开启 fragments 并且 sel 为 undefined 并且 children 不为 undefined 时，说明该 VNode 是 DocumentFragment\n      const children = vnode.children\n      vnode.elm = ( // 创建 DocumentFragment 作为该 VNode 的真实 DOM 节点\n        api.createDocumentFragment ?? documentFragmentIsNotSupported\n      )()\n      /******************************\n       * 执行 modules 的 create hook\n       * **************************\n       */\n      for (i = 0; i < cbs.create.length; ++i) {\n        cbs.create[i](emptyNode, vnode)\n      }\n      for (i = 0; i < children.length; ++i) { // 把子节点添加到 DocumentFragment 中，并实现递归添加\n        const ch = children[i]\n        if (ch !== null) {\n          api.appendChild(\n            vnode.elm,\n            createElm(ch as VNode, insertedVnodeQueue)\n          )\n        }\n      }\n    } else { // 以上条件都不符合，那么一定是文本节点\n      vnode.elm = api.createTextNode(vnode.text!)\n    }\n    return vnode.elm\n  }\n\n  /**\n   * 从 vnodes 中取 startIdx 到 endIdx 区间的节点插入到 before 前\n   * @param parentElm 父节点\n   * @param before 标杆节点\n   * @param vnodes VNode 数组\n   * @param startIdx 插入的起始指针\n   * @param endIdx 插入的结束指针\n   * @param insertedVnodeQueue VNode 等待队列，里面的 VNode 在挂载完毕后将被处理\n   */\n  function addVnodes(\n    parentElm: Node,\n    before: Node | null,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number,\n    insertedVnodeQueue: VNodeQueue\n  ): void {\n    for (; startIdx <= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx]\n      if (ch != null) { // 如果当前项不为空，则为 VNode，生成真实 DOM 并插入\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before)\n      }\n    }\n  }\n\n  /**\n   * 调用 destroy hook\n   * @param vnode VNode\n   */\n  function invokeDestroyHook(vnode: VNode): void {\n    const data = vnode.data\n    if (data !== undefined) { // 如果 data 不为 undefined，说明 VNode 是 DOM 节点\n      data?.hook?.destroy?.(vnode) // 调用 destroy hook\n      /*******************************\n       * 执行 modules 的 destroy hook\n       * ***************************\n       */\n      for (let i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode)\n      }\n      if (vnode.children !== undefined) { // 如果有子节点，还需要递归调用 invokeDestroyHook\n        for (let j = 0; j < vnode.children.length; ++j) {\n          const child = vnode.children[j]\n          if (child != null && typeof child !== 'string') { // 不为 null 或 string，说明 child 为 VNode\n            invokeDestroyHook(child)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * 从 vnodes 中取 startIdx 到 endIdx 区间的节点删除\n   * \n   * removeVnode 执行了 destroy hook、remove hook。\n   * \n   * @param parentElm 父节点\n   * @param vnodes VNode 数组\n   * @param startIdx 删除的起始指针\n   * @param endIdx 删除的结束指针\n   */\n  function removeVnodes(\n    parentElm: Node,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number\n  ): void {\n    for (; startIdx <= endIdx; ++startIdx) {\n      let listeners: number // 计数器\n      let rm: () => void // 删除的回调函数，每次调用都会是 listeners - 1，当 listeners = 0 时，触发删除操作\n      const ch = vnodes[startIdx]\n      if (ch != null) {\n        if (isDef(ch.sel)) { // sel 不为 undefined，说明是 DOM 节点\n          invokeDestroyHook(ch)\n          listeners = cbs.remove.length + 1 // 计数器的值 = module remove hook + 1，确保 hook 全部被调用且 rm 也被 hook 调用才触发删除操作\n          rm = createRmCb(ch.elm!, listeners)\n          /******************************\n           * 执行 modules 的 remove hook\n           * **************************\n           */\n          for (let i = 0; i < cbs.remove.length; ++i) {\n            cbs.remove[i](ch, rm)\n          }\n          const removeHook = ch?.data?.hook?.remove\n          if (isDef(removeHook)) {\n            removeHook(ch, rm)\n          } else {\n            rm() // 如果 ch 没有 remove hook，那么调用一次 rm 确保删除操作可以触发\n          }\n        } else { // sel 为 undefined，说明是文本节点，直接删除\n          api.removeChild(parentElm, ch.elm!)\n        }\n      }\n    }\n  }\n\n  /**\n   * 更新新老子节点策略。\n   * \n   *   diff 算法采用四指针 + 旧节点 key 缓存的方法进行高效命中，\n   * 当新旧节点命中，说明这两个节点为同一个节点，根据新节点对旧节点进行打补丁，\n   * 并根据新节点的位置调整旧节点的位置。\n   * \n   * 四指针：\n   *  新前 -> 旧前\n   *  新后 -> 旧后\n   *  新后 -> 旧前\n   *  新前 -> 旧后\n   * \n   * 旧节点缓存：\n   *  遍历旧节点，把旧节点中所有带有 key 值的节点的下标进行缓存，\n   *  取新前节点对比缓存节点，如果命中，则打补丁并调整位置，如果未命中，说明新前节点为全新的 DOM 元素，直接暴力插入。\n   * \n   * 新节点有剩余，往旧节点添加剩余新节点。\n   * 旧节点有剩余，往旧节点删除剩余旧节点。\n   * \n   * @param parentElm 父节点\n   * @param oldCh 旧节点 VNode 数组\n   * @param newCh 新节点 Vnode 数组\n   * @param insertedVnodeQueue VNode 等待队列，里面的 VNode 在挂载完毕后将被处理\n   */\n  function updateChildren(\n    parentElm: Node,\n    oldCh: VNode[],\n    newCh: VNode[],\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    let oldStartIdx = 0 // 旧节点起始指针\n    let newStartIdx = 0 // 新节点起始指针\n    let oldEndIdx = oldCh.length - 1 // 旧节点结束指针\n    let oldStartVnode = oldCh[0] // 旧节点当前项\n    let oldEndVnode = oldCh[oldEndIdx] // 旧节点结束项\n    let newEndIdx = newCh.length - 1 // 新节点结束指针\n    let newStartVnode = newCh[0] // 新节点当前项\n    let newEndVnode = newCh[newEndIdx] // 新节点结束项\n    let oldKeyToIdx: KeyToIndexMap | undefined // 缓存带有 key 值的旧节点的索引值\n    let idxInOld: number // oldKeyToIdx 中查找出来的索引值\n    let elmToMove: VNode // oldCh 数组中在 idxInOld 位置的 VNode\n    let before: any\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (oldStartVnode == null) {\n        oldStartVnode = oldCh[++oldStartIdx]\n      } else if (oldEndVnode == null) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (newStartVnode == null) {\n        newStartVnode = newCh[++newStartIdx]\n      } else if (newEndVnode == null) {\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        /**\n         *   当 oldStartVnode 与 newStartVnode 的标识相同时，\n         * 对两者打补丁，oldStartIdx 和 newStartIdx 往后移\n         */\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        /**\n         *   当 oldEndVnode 与 newEndVnode 的标识相同时，\n         * 对两者打补丁，oldEndIdx 和 newEndIdx 往前移\n         */\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        /**\n         *   当 oldStartVnode 与 newEndVnode 的标识相同时，\n         * 对两者打补丁，把 oldStartVnode.elm 插入到 oldEndVnode.elm 的下一个节点前\n         * oldStartIdx 往后移、newEndIdx 往前移\n         */\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        api.insertBefore(\n          parentElm,\n          oldStartVnode.elm!,\n          api.nextSibling(oldEndVnode.elm!)\n        )\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        /**\n         *   当 oldEndVnode 与 newStartVnode 的标识相同时，\n         * 对两者打补丁，把 oldEndVnode.elm 插入到 oldStartVnode.elm 前\n         * oldEndIdx 往前移、newStartIdx 往后移\n         */\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        api.insertBefore(\n          parentElm,\n          oldEndVnode.elm!,\n          api.nextSibling(oldStartVnode.elm!)\n        )\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        /**\n         *   上述四种情况都不匹配，那么需要创建 oldCh 指针缓存，使用 newStartVnode 的 key 匹配缓存表。\n         * \n         * - 如果匹配成功，那么对旧节点打补丁，并插入到 oldStartVnode 前。\n         * - 如果匹配不成功，那么创建新节点并暴力插入到 oldStartVnode 前。\n         * \n         *  对于上述两种情况就指针都不需要移动：\n         *    1、对于第一种情况，newStartVnode 插入到 oldStartVnode 前，oldStartIdx 无影响。\n         *    2、对于第二种情况，由于指针只能一步一步移动，所以对于跳跃性的位置应对其标记，后续直接跳过该位置。\n         *    3、无论哪种情况，newStartIdx 都会后移，因为该判断无论如何都会使 newStartVnode 都会移动。\n         */\n        if (oldKeyToIdx === undefined) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        }\n        idxInOld = oldKeyToIdx[newStartVnode.key as string]\n        if (isUndef(idxInOld)) { // 如果新节点的 key 值在旧节点中找不到，那么 newStartVnode.elm 要查到 oldStartVnode.elm 之前\n          api.insertBefore(\n            parentElm,\n            createElm(newStartVnode, insertedVnodeQueue),\n            oldStartVnode.elm!\n          )\n        } else { // 如果新节点的 key 值与旧节点的 key 值相对应\n          elmToMove = oldCh[idxInOld]\n          if (elmToMove.sel !== newStartVnode.sel) { // 如果两者标签不一致，key 缓存失效，暴力插入\n            api.insertBefore(\n              parentElm,\n              createElm(newStartVnode, insertedVnodeQueue),\n              oldStartVnode.elm!\n            )\n          } else { // 如果两者 key 值、sel 都一致，说明是同一节点\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n            oldCh[idxInOld] = undefined as any // 该位置已匹配完成，将其置为 undefined 后续会跳过该位置\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n\n    if (newStartIdx <= newEndIdx) { // 如果旧节点已遍历完成，新节点还有剩余节点，说明对于旧节点新增了若干节点\n      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm\n      addVnodes(\n        parentElm,\n        before,\n        newCh,\n        newStartIdx,\n        newEndIdx,\n        insertedVnodeQueue\n      )\n    }\n    if (oldStartIdx <= oldEndIdx) { // 如果新节点已遍历完成，旧节点还有剩余节点，说明对于旧节点需要删除若干节点\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n\n  /**\n   * 新旧节点对比，并根据差异对 DOM 节点进行修改，对比规则：\n   *  1、当 vnode 没有文本时：\n   *    i、当 vnode 和 oldVnode 都有子节点且子节点不相同时，执行 diff 算法比较子节点。\n   *    ii、当 vnode 有子节点、oldVnode 没有子节点时，清除 oldVnode 的文本并向 DOM 节点插入 vnode 的子节点。\n   *    iii、当 oldVnode 有子节点、vnode 没有子节点时，向 DOM 节点删除所有子节点。\n   *    iiii、当 oldVnode 有文本时，将文本内容置空。\n   *  2、当 vnode 有文本时：\n   *    - 如果 oldVnode 有子节点，则全部删除。\n   *    - 将文本内容修改为 vnode 的文本内容\n   * \n   * patchVnode 函数执行了 update hook、postPatch hook。\n   * \n   * @param oldVnode 旧节点 VNode\n   * @param vnode 新节点 VNode\n   * @param insertedVnodeQueue VNode 等待队列，里面的 VNode 在挂载完毕后将被处理\n   * @returns \n   */\n  function patchVnode(\n    oldVnode: VNode,\n    vnode: VNode,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    const hook = vnode?.data?.hook\n    hook?.prepatch?.(oldVnode, vnode)\n    const elm = (vnode.elm = oldVnode.elm)! // 把 oldVnode.elm 赋值给 vnode.elm\n    const oldCh = oldVnode.children as VNode[]\n    const ch = vnode.children as VNode[]\n    if (oldVnode === vnode) return\n    if (vnode.data !== undefined) { // data 不为 undefined，说明是 DOM 节点\n      /******************************\n       * 执行 modules 的 update hook\n       * **************************\n       */\n      for (let i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode)\n      }\n      vnode.data.hook?.update?.(oldVnode, vnode) // 执行 updatre hook\n    }\n    if (isUndef(vnode.text)) { // 如果新节点没有文本的前提下\n      if (isDef(oldCh) && isDef(ch)) { // 如果都有子节点，并且都不相同\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue) // 执行 diff 算法\n        }\n      } else if (isDef(ch)) { // 如果新节点有子节点，旧节点没有子节点\n        if (isDef(oldVnode.text)) { // 如果旧节点有文本，那么需要置空\n          api.setTextContent(elm, '')\n        }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) // 向 DOM 节点添加新节点中的子节点\n      } else if (isDef(oldCh)) { // 如果旧节点有子节点，新节点没有子节点\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1) // 把旧节点的所有子节点都删除\n      } else if (isDef(oldVnode.text)) { // 如果旧节点有文本，那么需要置空\n        api.setTextContent(elm, '')\n      }\n    } else if (oldVnode.text !== vnode.text) { // 新节点有文本的前提下\n      if (isDef(oldCh)) { // 如果旧节点有子节点，新节点没有子节点，则删除旧节点的所有子节点\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n      }\n      api.setTextContent(elm, vnode.text!)\n    }\n    hook?.postpatch?.(oldVnode, vnode) // 执行 postPatch hook\n  }\n\n  /**\n   * patch 的作用是对比 oldVnode 和 vnode 的异同，根据情况进行打补丁或替换操作：\n   *  1、如果旧节点是 DOM 元素，则创建空的 VNode。\n   *  2、如果旧节点与新节点是同一节点，则打补丁。\n   *  3、如果旧节点与新节点不是同一节点，则替换。\n   * \n   * patch 执行了 modules pre hook、vnode insert hook、modules post hook。\n   * \n   * @param oldVnode 旧节点\n   * @param vnode 新节点\n   * @returns VNode\n   */\n  return function patch(\n    oldVnode: VNode | Element | DocumentFragment,\n    vnode: VNode\n  ): VNode {\n    let i: number\n    let elm: Node\n    let parent: Node\n    const insertedVnodeQueue: VNodeQueue = []\n    /****************************\n     * 执行 modules 的 pre hook\n     * ************************\n     */\n    for (i = 0; i < cbs.pre.length; ++i) {\n      cbs.pre[i]()\n    }\n\n    if (isElement(api, oldVnode)) { // oldVnode 是 Element，那么创建一个空的 VNode 并赋给 oldVnode\n      oldVnode = emptyNodeAt(oldVnode)\n    } else if (isDocumentFragment(api, oldVnode)) { // 同理\n      oldVnode = emptyDocumentFragmentAt(oldVnode)\n    }\n\n    if (sameVnode(oldVnode, vnode)) { // 如果对比的节点为同一节点，执行 patchVnode 对比\n      patchVnode(oldVnode, vnode, insertedVnodeQueue)\n    } else { // 如果不是同一节点，则把新节点插入，老节点移除\n      elm = oldVnode.elm!\n      parent = api.parentNode(elm) as Node\n\n      createElm(vnode, insertedVnodeQueue)\n\n      if (parent !== null) {\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))\n        removeVnodes(parent, [oldVnode], 0, 0)\n      }\n    }\n    /*****************************\n     * 执行 vnode 的 insert hook\n     * *************************\n     */\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])\n    }\n    /*****************************\n     * 执行 modules 的 post hook\n     * *************************\n     */\n    for (i = 0; i < cbs.post.length; ++i) {\n      cbs.post[i]()\n    }\n    return vnode\n  }\n}\n\n// END\n","import { vnode, VNode, VNodeData } from './vnode'\nimport * as is from './is'\n\nexport type VNodes = VNode[]\nexport type VNodeChildElement = // VNode 的子元素可以是一些这些类型\n  | VNode\n  | string\n  | number\n  | String\n  | Number\n  | undefined\n  | null\nexport type ArrayOrElement<T> = T | T[]\nexport type VNodeChildren = ArrayOrElement<VNodeChildElement> // VNodeChildren 可以是单个 VNode 或 VNode 数组\n\n/**\n * 为 svg 元素添加命名空间 http://www.w3.org/2000/svg\n * @param data 属性\n * @param children 子节点\n * @param sel 选择器\n */\nexport function addNS(\n  data: any,\n  children: Array<VNode | string> | undefined,\n  sel: string | undefined\n) {\n  data.ns = 'http://www.w3.org/2000/svg'\n  if (sel !== 'foreignObject' && children !== undefined) {\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i]\n      if (typeof child === 'string') continue\n      const childData = child.data\n      if (childData !== undefined) {\n        addNS(childData, child.children as VNodes, child.sel)\n      }\n    }\n  }\n}\n\n/**\n * h 函数的作用是对数据进行处理，最终得到 VNode\n * \n * h 函数具有四种用法：\n * \n *  1、单纯的空标签，如 <span></span>\n *  2、具有属性的空标签，如 <span id='text'></span>\n *  3、没有属性，具有子元素，如 <span> hello </span>\n *  4、具有属性，具有子元素，如 <span id='text'> hello </span>\n * \n *  @param sel DOM 选择器\n *  @param b 根据四种情况进行确定的值\n *  @param c 根据四种情况进行确定的值\n *  @return VNode\n */\nexport function h(sel: string): VNode\nexport function h(sel: string, data: VNodeData | null): VNode\nexport function h(sel: string, children: VNodeChildren): VNode\nexport function h(\n  sel: string,\n  data: VNodeData | null,\n  children: VNodeChildren,\n): VNode\nexport function h(sel: any, b?: any, c?: any): VNode {\n\n  let data: VNodeData = {} // 属性\n  let children: any // 子元素，注意 children 的最终形态只能是数组或 undefined\n  let text: any // 文本\n\n  if (c !== undefined) { // 处理参数 c，当 c 存在，说明有子节点\n    if (b !== null) { // b 不为 null，那么 b 只能是 VNodeData 类型的对象\n      data = b\n    }\n    if (is.array(c)) {\n      children = c\n    } else if (is.primitive(c)) { // 当 c 为数字或字符串时，那么 c 是文本节点\n      text = c.toString()\n    } else if (c && c.sel) { // c 为一个 VNode\n      children = [c] // 为什么是数组，请看 children 的定义注解\n    }\n  } else if (b !== undefined && b !== null) { // 处理参数 b，因为 b 可能是属性，也可能是子节点\n    if (is.array(b)) {\n      children = b\n    } else if (is.primitive(b)) {\n      text = b.toString()\n    } else if (b && b.sel) {\n      children = [b]\n    } else { // 以上三种情况都是判断 b 参数是否是子节点的，如果都不满足，那么 b 参数只能是属性\n      data = b\n    }\n  }\n\n  if (children !== undefined) {\n    /**\n     *   h 函数子节点传参时可以是一个 Array<number | string>，如 h('div', ['hello', 666])，\n     * 而 VNode 是一个对象，所以遍历的目的是把上述类型转换成 VNode\n     */\n    for (let i = 0; i < children.length; ++i) {\n      if (is.primitive(children[i])) {\n        children[i] = vnode(\n          undefined,\n          undefined,\n          undefined,\n          children[i],\n          undefined,\n        )\n      }\n    }\n  }\n  if ( // 如果 sel === 'svg'，说明该 VNode 是 svg 元素，为其添加命名空间\n    sel[0] === \"s\" &&\n    sel[1] === \"v\" &&\n    sel[2] === \"g\" &&\n    (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")\n  ) {\n    addNS(data, children, sel)\n  }\n  return vnode(sel, data, children, text, undefined)\n}\n\n/**\n * 创建 DoucmentFragment VNode\n * @param children 虚拟节点数组\n * @returns VNode\n */\nexport function fragment(children: VNodeChildren): VNode {\n  let c: any\n  let text: any\n\n  if (is.array(children)) { // 只能命中 children 为数组的情况，下面两种貌似不会触发\n    c = children\n  } else if (is.primitive(c)) {\n    text = children\n  } else if (c && c.sel) {\n    c = [children]\n  }\n\n  if (c !== undefined) {\n    for (let i = 0; i < c.length; ++i) {\n      if (is.primitive(c[i])) { // 把文本节点转为 VNode\n        c[i] = vnode(undefined, undefined, undefined, c[i], undefined)\n      }\n    }\n  }\n\n  return vnode(undefined, {}, c, text, undefined)\n}\n\n// END\n","import { VNode, VNodeData } from './vnode'\nimport { h, addNS } from './h'\n\nexport interface ThunkData extends VNodeData { // 声明 Thunk VNode 的属性，这里表明这两个属性为 Thunk VNode 专属\n  fn: () => VNode\n  args: any[]\n}\n\nexport interface Thunk extends VNode { // 声明 Thunk VNode 的类型\n  data: ThunkData\n}\n\nexport interface ThunkFn { // 声明 Thunk 方法的类型\n  (sel: string, fn: (...args: any[]) => any, args: any[]): Thunk\n  (sel: string, key: any, fn: (...args: any[]) => any, args: any[]): Thunk\n}\n\n/**\n * 把 vnode 的各项属性复制到 thunk 中\n * @param vnode VNode\n * @param thunk VNode\n */\nfunction copyToThunk(vnode: VNode, thunk: VNode): void {\n  const ns = thunk.data?.ns;\n  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;\n  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args\n  thunk.data = vnode.data\n  thunk.children = vnode.children\n  thunk.text = vnode.text\n  thunk.elm = vnode.elm\n  if (ns) addNS(thunk.data, thunk.children, thunk.sel)\n}\n\n/**\n * \n * @param thunk VNode\n */\nfunction init(thunk: VNode): void {\n  const cur = thunk.data as VNodeData\n  const vnode = (cur.fn as any)(...cur.args!)\n  copyToThunk(vnode, thunk)\n}\n\n/**\n * \n * @param oldVnode VNode\n * @param thunk VNode\n * @returns \n */\nfunction prepatch(oldVnode: VNode, thunk: VNode): void {\n  let i: number\n  const old = oldVnode.data as VNodeData\n  const cur = thunk.data as VNodeData\n  const oldArgs = old.args\n  const args = cur.args\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\n    copyToThunk((cur.fn as any)(...args!), thunk)\n  }\n  for (i = 0; i < (args as any).length; ++i) {\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\n      copyToThunk((cur.fn as any)(...args!), thunk)\n      return\n    }\n  }\n  copyToThunk(oldVnode, thunk)\n}\n\n/**\n * \n * @param sel sel为 selector 的意思，意为 DOM 选择器\n * @param key VNode 的唯一标识\n * @param fn 渲染函数，参数为 args 数组解构，应返回 VNode\n * @param args fn 的参数\n * @returns VNode as ThunkFn\n */\nexport const thunk = function thunk(\n  sel: string,\n  key?: any,\n  fn?: any,\n  args?: any\n): VNode {\n  if (args === undefined) {\n    args = fn\n    fn = key\n    key = undefined\n  }\n  return h(sel, {\n    key: key,\n    hook: { init, prepatch },\n    fn: fn,\n    args: args,\n  })\n} as ThunkFn\n","/**\r\n * attributes 模块支持增删改查，支持各种属性\r\n * \r\n * js：h(\"a\", { attrs: { href: \"/foo\" } }, \"Go to Foo\")\r\n * \r\n * jsx：<div attrs={{ \"aria-label\": \"I'm a div\" }} />\r\n */\r\nimport { VNode, VNodeData } from '../vnode'\r\nimport { Module } from './module'\r\n\r\nexport type Attrs = Record<string, string | number | boolean> // Record<K, T>：相当于 { K: T }\r\n\r\nconst xlinkNS = 'http://www.w3.org/1999/xlink'\r\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace'\r\nconst colonChar = 58 // : code\r\nconst xChar = 120 // x code\r\n\r\n/**\r\n * module attrs hook\r\n * @param oldVnode VNode\r\n * @param vnode VNode\r\n * @returns \r\n */\r\nfunction updateAttrs(oldVnode: VNode, vnode: VNode): void {\r\n  let key: string\r\n  const elm: Element = vnode.elm as Element\r\n  let oldAttrs = (oldVnode.data as VNodeData).attrs // 旧节点的 attrs 对象\r\n  let attrs = (vnode.data as VNodeData).attrs // 新节点的 attrs 对象\r\n\r\n  if (!oldAttrs && !attrs) return // 如果新旧节点都没有 attrs 对象，则返回\r\n  if (oldAttrs === attrs) return // 如果新旧节点的 attrs 对象引用相同，说明两者为同一个节点，返回\r\n  oldAttrs = oldAttrs || {}\r\n  attrs = attrs || {}\r\n\r\n  // update modified attributes, add new attributes\r\n  for (key in attrs) {\r\n    const cur = attrs[key]\r\n    const old = oldAttrs[key]\r\n    if (old !== cur) { // 新旧节点属性值不相等时，才进行属性修改\r\n      if (cur === true) { // 如果是布尔属性，当 cur 为 true 时，设置该属性，如 <button disabled></button>\r\n        elm.setAttribute(key, '')\r\n      } else if (cur === false) { // 如果是布尔属性，当 cur 为 false 时，移除该属性\r\n        elm.removeAttribute(key)\r\n      } else { // 处理不是布尔属性的情况\r\n        /**\r\n         * TODO: 对属性前缀带 x 的不熟悉，该段会在查阅资料后再添加解释注释\r\n         */\r\n        if (key.charCodeAt(0) !== xChar) { // 属性前缀带 x 的将另行处理\r\n          elm.setAttribute(key, cur as any)\r\n        } else if (key.charCodeAt(3) === colonChar) {\r\n          // Assume xml namespace\r\n          elm.setAttributeNS(xmlNS, key, cur as any)\r\n        } else if (key.charCodeAt(5) === colonChar) {\r\n          // Assume xlink namespace\r\n          elm.setAttributeNS(xlinkNS, key, cur as any)\r\n        } else {\r\n          elm.setAttribute(key, cur as any)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  for (key in oldAttrs) {\r\n    if (!(key in attrs)) { // 如果当前属性在 attrs 中不存在，则删除该属性\r\n      elm.removeAttribute(key)\r\n    }\r\n  }\r\n}\r\n\r\nexport const attributesModule: Module = {\r\n  create: updateAttrs,\r\n  update: updateAttrs,\r\n}\r\n\r\n// END\r\n","/**\r\n *   class 模块提供了一种简单的方式来动态配置元素的 class 属性，\r\n * 这个模块值为一个对象形式的 class 数据，对象中类名需要映射为布尔值，\r\n * 以此来表示该类名是否应该出现在节点上。\r\n * \r\n * js：h(\"a\", { class: { active: true, selected: false } }, \"Toggle\")\r\n * \r\n * jsx：<div class={{ foo: true, bar: true }} />\r\n */\r\nimport { VNode, VNodeData } from '../vnode'\r\nimport { Module } from './module'\r\n\r\nexport type Classes = Record<string, boolean> // Record<K, T>：相当于 { K: T }\r\n\r\n/**\r\n * module class hook\r\n * @param oldVnode VNode\r\n * @param vnode VNode\r\n * @returns \r\n */\r\nfunction updateClass(oldVnode: VNode, vnode: VNode): void {\r\n  let cur: any\r\n  let name: string\r\n  const elm: Element = vnode.elm as Element\r\n  let oldClass = (oldVnode.data as VNodeData).class // 旧节点的 class 对象\r\n  let klass = (vnode.data as VNodeData).class // 新节点的 class 对象\r\n\r\n  if (!oldClass && !klass) return // 如果新旧节点都没有 class 对象，则返回\r\n  if (oldClass === klass) return // 如果新旧节点的 class 对象引用相同，说明两个节点相同，返回\r\n  oldClass = oldClass || {}\r\n  klass = klass || {}\r\n\r\n  for (name in oldClass) {\r\n    if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {\r\n      elm.classList.remove(name) // 如果旧节点的当前 class 项为 true，新节点的当前 class 项为 false，则删除当前 class 项\r\n    }\r\n  }\r\n\r\n  for (name in klass) {\r\n    cur = klass[name]\r\n    if (cur !== oldClass[name]) { // 如果新旧节点的当前 class 项不相同，根据情况进行操作\r\n      (elm.classList as any)[cur ? 'add' : 'remove'](name)\r\n    }\r\n  }\r\n}\r\n\r\nexport const classModule: Module = { create: updateClass, update: updateClass }\r\n\r\n// END\r\n","/**\r\n * dataset 模块允许你在 DOM 元素上设置自定义 data 属性，然后通过 HTMLElement.dataset 来访问这些属性\r\n * \r\n * js：h(\"button\", { dataset: { action: \"reset\" } }, \"Reset\")\r\n * \r\n * jsx：<div dataset={{ foo: \"bar\" }} />\r\n */\r\nimport { VNode, VNodeData } from '../vnode'\r\nimport { Module } from './module'\r\n\r\nexport type Dataset = Record<string, string> // Record<K, T>：相当于 { K: T }\r\n\r\nconst CAPS_REGEX = /[A-Z]/g\r\n\r\n/**\r\n * module dataset hook\r\n * \r\n * 生成规则：\r\n *  1、传入 dataset: { aaa: 'bbb' }，生成的属性为 <div data-aaa='bbb'></div>。\r\n *  2、传入 dataset: { aAa: 'bbb' }，生成的属性为 <div data-a-aa='bbb'></div>。\r\n * \r\n * 使用驼峰命名的属性最终都会被转成 -前缀。\r\n * \r\n * @param oldVnode VNode\r\n * @param vnode VNode\r\n * @returns \r\n */\r\nfunction updateDataset(oldVnode: VNode, vnode: VNode): void {\r\n  const elm: HTMLElement = vnode.elm as HTMLElement\r\n  let oldDataset = (oldVnode.data as VNodeData).dataset // 旧节点的 dataset 对象\r\n  let dataset = (vnode.data as VNodeData).dataset // 新节点的 dataset 对象\r\n  let key: string\r\n\r\n  if (!oldDataset && !dataset) return // 如果新旧节点都没有 dataset 对象，则返回\r\n  if (oldDataset === dataset) return // 如果新旧节点的 dataset 对象引用相同，说明两者为同一个节点，返回\r\n  oldDataset = oldDataset || {}\r\n  dataset = dataset || {}\r\n  const d = elm.dataset\r\n\r\n  for (key in oldDataset) {\r\n    if (!dataset[key]) { // 如果新节点的 dataset 没有当前属性，则向 DOM 元素删除该自定义属性\r\n      if (d) { // 可能存在大小写不一致的情况，如传入 aAa，而 DOM 元素中的 dataset 会转义为 aaa\r\n        if (key in d) {\r\n          delete d[key]\r\n        }\r\n      } else { // 这种情况必定会命中，如传入 aAa，无论设置或者删除我们生成的都是 data-a-aa\r\n        elm.removeAttribute(\r\n          // 对于 key 存在驼峰命名都会转为 -分割，如 fontSize 转为 font-size\r\n          'data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase()\r\n        )\r\n      }\r\n    }\r\n  }\r\n  for (key in dataset) {\r\n    if (oldDataset[key] !== dataset[key]) { // 如果新旧节点的自定义属性不相同，则修改\r\n      if (d) {\r\n        d[key] = dataset[key]\r\n      } else {\r\n        elm.setAttribute(\r\n          'data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase(),\r\n          dataset[key]\r\n        )\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const datasetModule: Module = {\r\n  create: updateDataset,\r\n  update: updateDataset\r\n}\r\n\r\n// END\r\n","/**\n * eventlisteners 模块提供了一个功能强大的事件监听器\n * \n * js：h(\"div\", { on: { click: clickHandler } })\n * \n * jsx：<div on={{ click: clickHandler }} />\n */\nimport { VNode, VNodeData } from '../vnode'\nimport { Module } from './module'\n\ntype Listener<T> = (this: VNode, ev: T, vnode: VNode) => void\n\n/**\n * {\n *  [key: event]: (this: VNode, ev: T, vnode: VNode) => void | Array<(this: VNode, ev: T, vnode: VNode) => void>\n * }\n */\nexport type On = { // 该类型的对象的键是事件名，其对应的值可以是单个事件、也可以是事件数组；注意：该事件是经过包装的事件\n  [N in keyof HTMLElementEventMap]?:\n  | Listener<HTMLElementEventMap[N]>\n  | Array<Listener<HTMLElementEventMap[N]>>\n} & {\n  [event: string]: Listener<any> | Array<Listener<any>>\n}\n\ntype SomeListener<N extends keyof HTMLElementEventMap> = // 事件处理器单项\n  | Listener<HTMLElementEventMap[N]>\n  | Listener<any>\n\n/**\n * 调用事件处理器\n * @param handler 包装事件或包装事件数组\n * @param vnode VNode\n * @param event 事件对象\n */\nfunction invokeHandler<N extends keyof HTMLElementEventMap>(\n  handler: SomeListener<N> | Array<SomeListener<N>>,\n  vnode: VNode,\n  event?: Event\n): void {\n  if (typeof handler === 'function') { // 如果包装事件是函数，则调用该事件\n    handler.call(vnode, event, vnode)\n  } else if (typeof handler === 'object') { // 如果是数组，则调用每项事件\n    for (let i = 0; i < handler.length; ++i) {\n      invokeHandler(handler[i], vnode, event)\n    }\n  }\n}\n\n/**\n *  事件监听器触发的处理函数，\n * 负责检测事件监听器绑定的 VNode 中的事件对象中的某事件类型是否符合触发的事件类型，\n * 如果符合，则分发该事件的处理函数。\n * \n * 视图：\n *  VNode on: {\n *    click: [fn1, fn2, fn3],\n *    change: fn,\n *  }\n * \n *  触发 DOM click 事件，调用 handleEvent 检测到 Vnode on 对象中有 click 属性，那么依次调用 click 属性中的事件\n * \n * @param event 事件对象\n * @param vnode VNode\n */\nfunction handleEvent(event: Event, vnode: VNode) {\n  const name = event.type // 获取事件类型\n  const on = (vnode.data as VNodeData).on\n\n  if (on && on[name]) { // 如果这个类型的包装事件存在，则调用\n    invokeHandler(on[name], vnode, event)\n  }\n}\n\n/**\n * 创建一个事件监听器\n * @returns handler\n */\nfunction createListener() {\n  return function handler(event: Event) {\n    handleEvent(event, (handler as any).vnode)\n  }\n}\n\n/**\n * module eventListeners hook\n * \n *  eventListeners 模块十分巧妙，对于每种事件类型都仅对应一个事件监听器进行分发，\n * 实现一对多。每次更新只需关注事件的类型是否变化来确定增加或移除事件监听器即可，\n * 而对于 on 对象中每个事件类型中的事件处理函数 eventListeners 模块并不需要关心。\n * \n * 打个比方：\n *  检测 on 对象，如果 on 对象中有 click 事件类型，则为 click 事件类型添加事件监听器 listener，\n * 对于 click 的事件处理函数是什么，怎么变更并不需要关心。在下一次更新时检测 on 对象，发现 click 事件类型被移除，那么只需移除 click 的事件监听器即可。\n * \n * @param oldVnode VNode\n * @param vnode? VNode | undefined\n * @returns \n */\nfunction updateEventListeners(oldVnode: VNode, vnode?: VNode): void {\n  const oldOn = (oldVnode.data as VNodeData).on\n  const oldListener = (oldVnode as any).listener // 旧节点的事件监听器\n  const oldElm: Element = oldVnode.elm as Element\n  const on = vnode && (vnode.data as VNodeData).on\n  const elm: Element = (vnode && vnode.elm) as Element\n  let name: string\n\n  if (oldOn === on) { // 如果事件对象的引用没发生改变，说明没有更改的事件，返回\n    return\n  }\n\n  if (oldOn && oldListener) {\n    if (!on) { // 如果 vnode 的事件类型不存在，可能是 vnode 的事件类型被移除，也可能是 oldVnode 被销毁，两种情况都需要移除所有事件监听器\n      for (name in oldOn) {\n        oldElm.removeEventListener(name, oldListener, false)\n      }\n    } else { // 如果 vnode 的事件类型存在，那么移除 oldVnode 中存在且 vnode 中不存在的事件监听器\n      for (name in oldOn) {\n        if (!on[name]) {\n          oldElm.removeEventListener(name, oldListener, false)\n        }\n      }\n    }\n  }\n\n  if (on) { // 如果 vnode 有事件对象，那么有添加事件的情况\n    const listener = ((vnode as any).listener = // 重用旧节点的事件监听器或创建一个新的事件监听器\n      (oldVnode as any).listener || createListener())\n    listener.vnode = vnode // 事件监听器存储的 VNode 对象指向 vnode\n\n    if (!oldOn) { // 如果旧节点没有事件对象，那么对所有事件类型都需要添加监听器\n      for (name in on) {\n        elm.addEventListener(name, listener, false)\n      }\n    } else { // 如果旧节点有事件对象，那么只需对旧节点没有而新节点有的事件类型添加监听器\n      for (name in on) {\n        if (!oldOn[name]) {\n          elm.addEventListener(name, listener, false)\n        }\n      }\n    }\n  }\n}\n\nexport const eventListenersModule: Module = {\n  create: updateEventListeners,\n  update: updateEventListeners,\n  destroy: updateEventListeners,\n}\n\n// END\n","/**\r\n *  props 模块允许你设置 DOM 元素的属性。\r\n * props 添加的属性只能被设置不能被移除，即使浏览器允许自定义添加或删除属性，该模块也不会尝试删除。\r\n * 这是因为原生 DOM 的属性也同样不支持被移除\r\n * \r\n * js：h(\"a\", { props: { href: \"/foo\" } }, \"Go to Foo\")\r\n * \r\n * jsx：<input props={{ name: \"foo\" }} />\r\n */\r\nimport { VNode, VNodeData } from '../vnode'\r\nimport { Module } from './module'\r\n\r\nexport type Props = Record<string, any> // Record<K, T>：相当于 { K: T }\r\n\r\n/**\r\n * module props hook\r\n * @param oldVnode VNode\r\n * @param vnode VNode\r\n * @returns \r\n */\r\nfunction updateProps(oldVnode: VNode, vnode: VNode): void {\r\n  let key: string\r\n  let cur: any\r\n  let old: any\r\n  const elm = vnode.elm\r\n  let oldProps = (oldVnode.data as VNodeData).props // 旧节点的 props 对象\r\n  let props = (vnode.data as VNodeData).props // 新节点的 props 对象\r\n\r\n  if (!oldProps && !props) return // 如果新旧节点都没有 props 对象，则返回\r\n  if (oldProps === props) return // 如果新旧节点的 props 对象引用相同，说明两者为同一个节点，返回\r\n  oldProps = oldProps || {}\r\n  props = props || {}\r\n\r\n  for (key in props) { // 只遍历 props，所以只是添加或修改属性，不能删除属性\r\n    cur = props[key] // 新节点的当前属性的值\r\n    old = oldProps[key] // 旧节点的当前属性的值\r\n    if (old !== cur && (key !== 'value' || (elm as any)[key] !== cur)) {\r\n      /**\r\n       * 如果新旧节点的属性值不相等，并且 DOM 元素的属性值和新节点的属性值不一致，则修改 DOM 元素的属性值\r\n       * \r\n       * 注意，如果有 value 值，那么需要验证 DOM 元素的 value 值是否不一致\r\n       */\r\n      (elm as any)[key] = cur\r\n    }\r\n  }\r\n}\r\n\r\nexport const propsModule: Module = { create: updateProps, update: updateProps }\r\n\r\n// END\r\n","/**\r\n * style 模块用于让动画更加平滑，它的核心是允许你再元素上设置 CSS 属性。\r\n * \r\n * 特性：\r\n *  1、自定义属性(CSS 变量)：属性名需要以 -- 为前缀，如：style: { \"--warnColor\": \"yellow\" }。\r\n *  2、delayed：延迟参数，每当这些属性变动时需要到下一帧之后才会应用更改。\r\n *  3、remove：在元素即将从 DOM 中移除时生效，应用的样式应该通过 CSS transition 设置，只有当所有动画执行完成后元素才会从 DOM 中移除。\r\n *  4、destroy：\r\n * \r\n * js：h(\r\n        \"span\",\r\n        {\r\n          style: {\r\n            border: \"1px solid #bada55\",\r\n            color: \"#c0ffee\",\r\n            fontWeight: \"bold\",\r\n          },\r\n        },\r\n        \"Say my name, and every colour illuminates\"\r\n      )\r\n\r\n * jsx：<div\r\n          style={{\r\n            border: \"1px solid #bada55\",\r\n            color: \"#c0ffee\",\r\n            fontWeight: \"bold\",\r\n          }}\r\n        />\r\n */\r\nimport { VNode, VNodeData } from '../vnode'\r\nimport { Module } from './module'\r\n\r\nexport type VNodeStyle = Record<string, string> & { // Record<K, T>：相当于 { K: T }，& 对类型进行扩展\r\n  delayed?: Record<string, string>\r\n  remove?: Record<string, string>\r\n}\r\n\r\nconst raf = // 动画帧函数优雅降级\r\n  (typeof window !== 'undefined' &&\r\n    window.requestAnimationFrame.bind(window)) ||\r\n  setTimeout\r\nconst nextFrame = function (fn: any) { // 下一帧调用函数\r\n  raf(function () { // 当前帧\r\n    raf(fn) // 下一帧\r\n  })\r\n}\r\nlet reflowForced = false\r\n\r\n/**\r\n * 在下一帧设置对象中的属性的值\r\n * @param obj 对象\r\n * @param prop 属性\r\n * @param val 属性值\r\n */\r\nfunction setNextFrame(obj: any, prop: string, val: any): void {\r\n  nextFrame(function () {\r\n    obj[prop] = val\r\n  })\r\n}\r\n\r\n/**\r\n * 在 create、update 生命周期时调用。\r\n * \r\n * 对 DOM 元素的样式表进行修改或删除，触发 delayed 延迟函数。\r\n * \r\n * @param oldVnode VNode\r\n * @param vnode VNode\r\n * @returns \r\n */\r\nfunction updateStyle(oldVnode: VNode, vnode: VNode): void {\r\n  let cur: any\r\n  let name: string\r\n  const elm = vnode.elm\r\n  let oldStyle = (oldVnode.data as VNodeData).style // 旧节点的 style 对象\r\n  let style = (vnode.data as VNodeData).style // 新节点的 style 对象\r\n\r\n  if (!oldStyle && !style) return // 如果新旧节点都没有 style 对象，则返回\r\n  if (oldStyle === style) return // 如果新旧节点的 style 对象引用相同，说明两个节点相同，返回\r\n  oldStyle = oldStyle || {}\r\n  style = style || {}\r\n  const oldHasDel = 'delayed' in oldStyle // 旧节点是否存在 delayed 对象\r\n\r\n  for (name in oldStyle) { // 如果该属性在旧节点有而在新节点没有，则删除\r\n    if (!style[name]) {\r\n      if (name[0] === '-' && name[1] === '-') { // 对于自定义属性，需要在样式表中移除属性\r\n        (elm as any).style.removeProperty(name)\r\n      } else { // 其余属性则置空即可\r\n        (elm as any).style[name] = ''\r\n      }\r\n    }\r\n  }\r\n  for (name in style) {\r\n    cur = style[name]\r\n    if (name === 'delayed' && style.delayed) { // 检测是否存在 delayed 对象\r\n      for (const name2 in style.delayed) { // 如果存在，那么应用动画帧\r\n        cur = style.delayed[name2]\r\n        if (!oldHasDel || cur !== (oldStyle.delayed as any)[name2]) {\r\n          /**\r\n           * 如果旧节点不存在 delayed 对象，或者新节点的 delayed 对象的当前属性值不等于旧节点的 delayed 对象的当前属性值，\r\n           * 那么需要在下一帧改变属性。\r\n           */\r\n          setNextFrame((elm as any).style, name2, cur)\r\n        }\r\n      }\r\n    } else if (name !== 'remove' && cur !== oldStyle[name]) { // 排除 remove 属性，并且当前属性不相同，则修改\r\n      if (name[0] === '-' && name[1] === '-') {\r\n        (elm as any).style.setProperty(name, cur)\r\n      } else {\r\n        (elm as any).style[name] = cur\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 在 destroy 生命周期时调用。\r\n * \r\n * 在 destroy 生命周期触发时设置 DOM 元素的样式表。\r\n * \r\n * @param vnode VNode\r\n * @returns \r\n */\r\nfunction applyDestroyStyle(vnode: VNode): void {\r\n  let style: any\r\n  let name: string\r\n  const elm = vnode.elm\r\n  const s = (vnode.data as VNodeData).style\r\n  if (!s || !(style = s.destroy)) return // 如果没有 style 对象或者 style 对象中没有 destroy 对象，返回\r\n  for (name in style) { // 把 destroy 对象中的属性应用到 DOM 元素的样式表中\r\n    (elm as any).style[name] = style[name]\r\n  }\r\n}\r\n\r\n/**\r\n * 在 remove 生命周期时调用。\r\n * \r\n * 在元素被删除时执行动画，被执行的动画属性应存在于 remove 对象中，且 transition 也应设置过渡属性。\r\n * \r\n * 如：\r\n *  style: {\r\n      opacity: \"1\",\r\n      transition: \"opacity 1s\",\r\n      remove: { opacity: \"0\" },\r\n    }\r\n\r\n    transition 属性指定了 opacity 为过渡属性，且 remove 也指定了 opacity，那么 opacity 属性符合执行删除动画的条件。\r\n * \r\n * @param vnode VNode\r\n * @param rm 计时回调函数，init 模块中有声明，rm 调用一次表示有一个 remove hook 被调用，当所有 remove hook 被调用完毕，触发删除 DOM 操作\r\n * @returns \r\n */\r\nfunction applyRemoveStyle(vnode: VNode, rm: () => void): void {\r\n  const s = (vnode.data as VNodeData).style\r\n  if (!s || !s.remove) { // 如果没有 style 对象或者 style 对象中没有remove 对象，返回\r\n    rm()\r\n    return\r\n  }\r\n  if (!reflowForced) { // 强制回流一次，暂未知有什么用途，猜测是强制刷新当前元素的状态\r\n    (vnode.elm as any).offsetLeft\r\n    reflowForced = true\r\n  }\r\n  let name: string\r\n  const elm = vnode.elm\r\n  let i = 0\r\n  const style = s.remove\r\n  let amount = 0 // 计数器，用于统计需要转换的属性\r\n  const applied: string[] = []\r\n  for (name in style) {\r\n    applied.push(name); // 存储 vnode 中的 style 中的 remove 对象中的属性标记\r\n    (elm as any).style[name] = style[name] // 把 remove 对象中的属性应用到 DOM 样式表中\r\n  }\r\n  const compStyle = getComputedStyle(elm as Element) // 获取样式表\r\n  const props = (compStyle as any)['transition-property'].split(', ') // 获取样式表中记录的过渡转换属性表\r\n  for (; i < props.length; ++i) {\r\n    if (applied.indexOf(props[i]) !== -1) { // 累计 applied 和 transition-property 都存在的属性总数\r\n      amount++\r\n    }\r\n  }\r\n  (elm as Element).addEventListener(\r\n    'transitionend', // css 在转换完成后触发\r\n    function (ev: TransitionEvent) {\r\n      if (ev.target === elm) --amount // 目标元素完成转换，计数器 - 1\r\n      if (amount === 0) rm() // 所有元素完成转换，执行 rm 表示当前 hook 已调用完毕\r\n    }\r\n  )\r\n}\r\n\r\n/**\r\n * 在 pre 生命周期时调用。\r\n * \r\n * 重置 回流阀。\r\n */\r\nfunction forceReflow() {\r\n  reflowForced = false\r\n}\r\n\r\nexport const styleModule: Module = {\r\n  pre: forceReflow,\r\n  create: updateStyle,\r\n  update: updateStyle,\r\n  destroy: applyDestroyStyle,\r\n  remove: applyRemoveStyle,\r\n}\r\n\r\n// END\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","htmlDomApi","createElement","tagName","options","document","createElementNS","namespaceURI","qualifiedName","createTextNode","text","createDocumentFragment","createComment","insertBefore","parentNode","newNode","referenceNode","removeChild","node","child","appendChild","nextSibling","elm","setTextContent","textContent","getTextContent","isElement","nodeType","isText","isComment","isDocumentFragment","vnode","sel","data","children","undefined","array","Array","isArray","primitive","s","String","Number","isUndef","isDef","emptyNode","sameVnode","vnode1","vnode2","isSameKey","isSameIs","is","documentFragmentIsNotSupported","Error","createKeyToOldIdx","beginIdx","endIdx","map","i","hooks","init","modules","domApi","cbs","create","update","remove","destroy","pre","post","api","hook","currentHook","push","emptyNodeAt","id","classes","getAttribute","c","split","join","toLowerCase","emptyDocumentFragmentAt","frag","createRmCb","childElm","listeners","parent","createElm","insertedVnodeQueue","hashIdx","indexOf","dotIdx","hash","length","dot","tag","slice","Math","min","ns","setAttribute","replace","ch","insert","experimental","fragments","addVnodes","parentElm","before","vnodes","startIdx","invokeDestroyHook","j","removeVnodes","rm","removeHook","patchVnode","oldVnode","prepatch","oldCh","newCh","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","updateChildren","postpatch","addNS","childData","h","b","toString","fragment","copyToThunk","thunk","fn","args","cur","old","oldArgs","updateAttrs","oldAttrs","attrs","removeAttribute","charCodeAt","setAttributeNS","attributesModule","updateClass","name","oldClass","class","klass","classList","classModule","CAPS_REGEX","updateDataset","oldDataset","dataset","d","datasetModule","invokeHandler","handler","event","handleEvent","type","on","updateEventListeners","oldOn","oldListener","listener","oldElm","removeEventListener","addEventListener","eventListenersModule","updateProps","oldProps","props","propsModule","raf","window","requestAnimationFrame","bind","setTimeout","reflowForced","setNextFrame","val","updateStyle","oldStyle","style","oldHasDel","removeProperty","delayed","name2","setProperty","styleModule","offsetLeft","amount","applied","getComputedStyle","ev","target"],"sourceRoot":""}